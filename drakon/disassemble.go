// Autogenerated with DRAKON Editor 1.33

package bbcdisasm

import (
        "bytes"
        "fmt"
        "io"
        "sort"
        "strconv"
        "strings"
        "text/template"
)

// Which types of data should the visit callback to walk be invoked for.
// This has only the most basic support right now.
type visitMask uint

const (
        vtCode visitMask = 1 << iota
        vtData

        vtNone = visitMask(0)
        vtAll  = ^visitMask(0)
)

type varDef struct {
        Sval string
        Ival uint
}

// Disassembler converts byte code to a textual representation
type Disassembler struct {
        Program  []byte // The 6502 program to be disassembled
        MaxBytes uint   // Maximum number of program bytes to disassemble
        Offset   uint   // Starting offset to begin disassembly

        // The load address of the program, required to correctly compute absolute
        // addresses for relative branches.
        BranchAdjust uint

        // The set of addresses in the program that the disassembler should ensure
        // to disassemble. This is useful in cases where the disassembler skips
        // addresses due to misinterpreting data bytes as opcodes.
        // Will be modified by Disassemble().
        CodeAddrs []uint

        usedOSAddress map[uint]bool
        usedOSVector  map[uint]bool
        branchTargets map[uint]int
        vars          map[string]varDef
}






func (self *Disassembler) AddVar(name, value string) error {
    var base int
    ovalue := value
    if value[0] == '&' {
        value = strings.Trim(value, "&")
        base = 16
    }
    ival, err := strconv.ParseInt(value, base, 0)
    if err != nil {
        return err
    }
    self.vars[name] = varDef{ovalue, uint(ival)}
    return nil
}

func (self *Disassembler) Disassemble(w io.Writer)  {
    if len(d.CodeAddrs) > 0 {
        sort.Slice(d.CodeAddrs, func(i, j int) bool { return d.CodeAddrs[i] < d.CodeAddrs[j] })
        for i, ca := range self.CodeAddrs {
            self.CodeAddrs[i] = ca - self.BranchAdjust
        }
    }
    self.findBranchTargets()
    
    distem, _ := template.New("disasm").Parse(disasmHeader)
    data := struct {
    	UsedOSAddress map[uint]bool
    	OSAddress     map[uint]string
    	UsedOSVector  map[uint]bool
    	OSVector      map[uint]string
    	Vars          map[string]varDef
    	LoadAddr      uint
    }{d.usedOSAddress, addressToOsCallName, d.usedOSVector, osVectorAddresses, d.vars, d.BranchAdjust}
    
    err := distem.Execute(w, data);
    if err != nil {
        panic(err)
    }
    self.walk(vtAll, func2 int)
}

func  NewDisassembler(program []byte) *Disassembler {
    return &Disassembler{
    	Program:       program,
    	usedOSAddress: make(map[uint]bool),
    	usedOSVector:  make(map[uint]bool),
    	vars:          make(map[string]varDef),
    }
}

func  appendPrintableBytes(sb *strings.Builder, b []byte)  {
    appendSpaces(sb, max(44-sb.Len(), 1))
    for _, c := range b {
        sb.WriteByte(toChar(c))
    }
}

func  appendSpaces(sb *strings.Builder, ns int)  {
    sb.Write(bytes.Repeat([]byte{' '}, ns))
}

func (self *Disassembler) decode(op Opcode, bytes []byte, cursor uint) string {
    _sw6670000_ := 0
    if bytes[0] == OpJMPAbsolute || bytes[0] == OpJSRAbsolute {
        return genAbsoluteOsCall(bytes, self.branchTargets)
    }
    if op.branchOrJump() == btBranch {
        return genBranch(bytes, cursor, self.BranchAdjust, self.branchTargets)
    }
    _sw6670000_ = op.AddrMode
    if _sw6670000_ == None {
        return ""
    } else {
        if _sw6670000_ == Accumulator {
            return "A"
        } else {
            if _sw6670000_ == Immediate {
                return fmt.Sprintf("#&%02X", bytes[1])
            } else {
                if _sw6670000_ == Absolute {
                    val := (uint(bytes[2]) << 8) + uint(bytes[1])
                    ok := osVectorAddresses[val];
                    if osv, ok {
                        return osv
                    }
                    ok := osVectorAddresses[val&^uint(1)];
                    if osv, ok {
                        return osv + "+1"
                    }
                    ok := d.lookupVar(val);
                    if dvar, ok {
                        return dvar
                    }
                    return fmt.Sprintf("&%04X", val)
                } else {
                    if _sw6670000_ == ZeroPage {
                        ok := self.lookupVar(uint(bytes[1]));
                        if dvar, ok {
                            return dvar
                        }
                        return fmt.Sprintf("&%02X", bytes[1])
                    } else {
                        if _sw6670000_ == ZeroPageX {
                            ok := self.lookupVar(uint(bytes[1]));
                            if dvar, ok {
                                return dvar + ",X"
                            }
                            return fmt.Sprintf("&%02X,X", bytes[1])
                        } else {
                            if _sw6670000_ == ZeroPageY {
                                ok := self.lookupVar(uint(bytes[1]));
                                if dvar, ok {
                                    return dvar + ",Y"
                                }
                                return fmt.Sprintf("&%02X,Y", bytes[1])
                            } else {
                                if _sw6670000_ == Indirect {
                                    val := (uint(bytes[2]) << 8) + uint(bytes[1])
                                    ok := self.lookupVar(val);
                                    if dvar, ok {
                                        return "(" + dvar + ")"
                                    }
                                    return fmt.Sprintf("(&%04X)", val)
                                } else {
                                    if _sw6670000_ == AbsoluteX {
                                        val := (uint(bytes[2]) << 8) + uint(bytes[1])
                                        ok := self.lookupVar(val);
                                        if dvar, ok {
                                            return dvar + ",X"
                                        }
                                        return fmt.Sprintf("&%04X,X", val)
                                    } else {
                                        if _sw6670000_ == AbsoluteY {
                                            val := (uint(bytes[2]) << 8) + uint(bytes[1])
                                            ok := self.lookupVar(val);
                                            if dvar, ok {
                                                return dvar + ",Y"
                                            }
                                            return fmt.Sprintf("&%04X,Y", val)
                                        } else {
                                            if _sw6670000_ == IndirectX {
                                                ok := self.lookupVar(uint(bytes[1]));
                                                if dvar, ok {
                                                    return "(" + dvar + ",X)"
                                                }
                                                return fmt.Sprintf("(&%02X,X)", bytes[1])
                                            } else {
                                                if _sw6670000_ == IndirectY {
                                                    ok := self.lookupVar(uint(bytes[1]));
                                                    if dvar, ok {
                                                        return "(" + dvar + "),Y"
                                                    }
                                                    return fmt.Sprintf("(&%02X,Y)", bytes[1])
                                                } else {
                                                    if _sw6670000_ == default {
                                                        
                                                    } else {
                                                        panic("Not expected _sw6670000_")
                                                    }
                                                    return "UNKNOWN ADDRESS MODE"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

func (self *Disassembler) findBranchTargets()  {
    iloc := make(map[uint]bool)
    
    self.branchTargets = make(map[uint]int)
    
    self.walk(vtCode, func3 int)
    for k := range self.branchTargets {
        ok := iloc[k];
        if _, !ok {
            delete(self.branchTargets, k)
        }
    }
    bt := make([]int, len(self.branchTargets))
    i := 0
    for k := range d.branchTargets {
        bt[i] = int(k)
        i++
    }
    sort.Ints(bt)
    for i, v := range bt {
        self.branchTargets[uint(v)] = i
    }
}

func (self) func2(cursor uint, codeAddrIdx int, b byte, op Opcode, opOk bool) int {
    var sb strings.Builder
    ok := d.branchTargets[cursor+d.BranchAdjust];
    if targetIdx, ok {
        sb.WriteByte('.')
        sb.WriteString(fmt.Sprintf(labelFormatString, targetIdx))
        sb.WriteString("\n")
        w.Write([]byte(sb.String()))
        
        sb.Reset()
    }
    sb.WriteByte(' ')
    
    var advance uint
    if opOk {
        instruction := self.Program[cursor : cursor+op.Length]
        doc := isOpcodeDocumented(op)
        wai := willAssembleIdentically(op, instruction)
        
        var straddles bool
        if codeAddrIdx < len(self.CodeAddrs) {
            straddles = cursor+op.Length >= self.CodeAddrs[codeAddrIdx]
            if doc && wai && !straddles {
                self.printInstruction(&sb, op, instruction, cursor)
                
                advance = op.Length
            } else {
                if straddles {
                    nb := self.CodeAddrs[codeAddrIdx] - cursor
                    instruction = instruction[:nb]
                }
                printData(&sb, instruction, doc, cursor+self.BranchAdjust)
                if !doc {
                    sb.WriteString("UD ")
                    sb.WriteString(op.Name)
                }
                appendPrintableBytes(&sb, instruction)
                
                advance = uint(len(instruction))
            }
        }
    } else {
        bs := []byte{b}
        printData(&sb, bs, true, cursor+self.BranchAdjust)
        appendPrintableBytes(&sb, bs)
        advance = 1
    }
    sb.WriteByte('\n')
    w.Write([]byte(sb.String()))
    
    return int(advance)
}

func (self) func3(cursor uint, _ int, b byte, op Opcode, opOk bool) int {
    _sw8200000_ := 0
    iloc[cursor+self.BranchAdjust] = true
    if opOk {
        instruction := self.Program[cursor : cursor+op.Length]
        _sw8200000_ = op.branchOrJump()
        if _sw8200000_ == btBranch {
            boff := int(instruction[1])
            if boff > 127 {
                boff = boff - 256
            }
            boff += 2
            
            tgt := cursor + uint(boff) + self.BranchAdjust
            ok := self.branchTargets[tgt];
            if _, !ok {
                self.branchTargets[tgt] = 0
            }
        } else {
            if _sw8200000_ == btJump {
                if b != OpJMPIndirect {
                    tgt := (uint(instruction[2]) << 8) + uint(instruction[1])
                    ok := self.branchTargets[tgt];
                    if _, !ok {
                        self.branchTargets[tgt] = 0
                    }
                    ok := addressToOsCallName[tgt];
                    if _, ok {
                        self.usedOSAddress[tgt] = true
                    }
                }
            } else {
                if _sw8200000_ == btNeither {
                    
                } else {
                    panic("Not expected _sw8200000_")
                }
                if op.AddrMode == Absolute {
                    tgt := (uint(instruction[2]) << 8) + uint(instruction[1])
                    ok := osVectorAddresses[tgt];
                    if _, ok {
                        self.usedOSVector[tgt] = true
                    }
                }
            }
        }
        return len(instruction)
    }
    return 1
}

func  isOpcodeDocumented(op Opcode) bool {
    for _, u := range UndocumentedInstructions {
        if op.Name == u {
            return false
        }
    }
    return true
}

func (self *Disassembler) lookupVar(val uint) (name string, ok bool) {
    for varn, varv := range self.vars {
        if varv.Ival == val {
            return varn, true
        }
    }
    return "", false
}

func  max(a, b int) int {
    if a < b {
        return b
    }
    return a
}

func  printData(sb *strings.Builder, data []byte, bytesInComment bool, address uint)  {
    var out []string
    for _, i := range data {
        out = append(out, fmt.Sprintf("&%02X", i))
    }
    sb.WriteString("EQUB ")
    sb.WriteString(strings.Join(out, ","))
    
    appendSpaces(sb, max(24-sb.Len(), 1))
    sb.WriteString("\\ ")
    
    out = []string{fmt.Sprintf("&%04X", address)}
    if bytesInComment {
        for _, i := range data {
            out = append(out, fmt.Sprintf("%02X", i))
        }
    }
    sb.WriteString(strings.Join(out, " "))
    sb.WriteByte(' ')
}

func (self *Disassembler) printInstruction(sb *strings.Builder, op Opcode, instruction []byte, cursor uint)  {
    sb.WriteString(op.Name)
    sb.WriteByte(' ')
    sb.WriteString(self.decode(op, instruction, cursor))
    
    appendSpaces(sb, max(24-sb.Len(), 1))
    sb.WriteString("\\ ")
    
    out := []string{
    	fmt.Sprintf("&%04X", cursor+d.BranchAdjust),
    }
    for _, i := range instruction {
        out = append(out, fmt.Sprintf("%02X", i))
    }
    sb.WriteString(strings.Join(out, " "))
    
    appendPrintableBytes(sb, instruction)
}

func  toChar(b byte) byte {
    if b < 32 || b > 126 {
        return '.'
    }
    return b
}

func (self *Disassembler) walk(vm visitMask, fn func(cursor uint, codeAddrIdx int, b byte, op Opcode, opOk bool) int))  {
    cursor := self.Offset
    prevCur := cursor
    codeAddrIdx := 0
    cursor := self.Offset;
    for {
        if cursor < (self.Offset + self.MaxBytes) {
            
        } else {
            break
        }
        if codeAddrIdx < len(d.CodeAddrs) {
            ca := self.CodeAddrs[codeAddrIdx]
            if prevCur < ca && cursor >= ca {
                cursor = ca
                codeAddrIdx++
            }
        }
        prevCur = cursor
        b := self.Program[cursor]
        op, opOk := OpCodesMap[b]
        if ((opOk && codeAddrIdx < len(d.CodeAddrs)) && (cursor+op.Length >= self.CodeAddrs[codeAddrIdx])) && (vm&vtData == 0) {
            cursor = self.CodeAddrs[codeAddrIdx]
            continue
        }
        cursor += uint(fn(cursor, codeAddrIdx, b, op, opOk))
        cursor += uint(fn(cursor, codeAddrIdx, b, op, opOk));
    }
}

func  willAssembleIdentically(op Opcode, instruction []byte) bool {
    if op.AddrMode == Absolute || op.AddrMode == AbsoluteX || op.AddrMode == AbsoluteY {
        tgt := (uint(instruction[2]) << 8) + uint(instruction[1])
        if tgt < 0x100 {
            return false
        }
    }
    return true
}

// I am the footer.
// Символы Юникод

var disasmHeader = `\ ******************************************************************************
\
\ This disassembly was produced by bbcdisasm
\
\ ******************************************************************************

{{ if .UsedOSAddress }}\ OS Call Addresses
{{ $os := .OSAddress }}
{{- range $addr, $elem := .UsedOSAddress }}{{ printf "%-6s" (index $os $addr) }} = {{ printf "&%0X" $addr }}
{{ end }}
{{- end }}
{{ if .UsedOSVector }}\ OS Vector Addresses
{{ $vec := .OSVector }}
{{- range $addr, $elem := .UsedOSVector }}{{ printf "%-5s" (index $vec $addr) }} = {{ printf "&%0X" $addr }}
{{ end }}
{{- end }}
{{ if .Vars }}\ Defined Variables
{{ $var := .Vars }}
{{- range $name, $value := .Vars }}{{ printf "%-5s" $name }} = {{ print $value.Sval }}
{{ end }}
{{- end }}
{{ if .LoadAddr }}CODE% = {{ printf "&%X" .LoadAddr }}

ORG CODE%
{{ else -}}
{{ end }}
